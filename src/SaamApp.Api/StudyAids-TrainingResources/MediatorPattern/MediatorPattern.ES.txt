El patrón Mediator es un patrón de comportamiento que promueve el acoplamiento débil entre objetos mediante el uso de un objeto mediador para gestionar las interacciones entre ellos.
En este patrón, los objetos no se comunican directamente entre sí, sino que envían mensajes al objeto mediador, que luego coordina las acciones apropiadas con otros objetos. Esto ayuda a reducir la complejidad de las interacciones entre objetos y puede hacer que el sistema sea más fácil de mantener y modificar con el tiempo.
El patrón Mediator es particularmente útil en sistemas con interacciones complejas entre objetos, o cuando hay muchos objetos que necesitan interactuar entre sí de una manera específica. También puede ayudar a simplificar las pruebas y la depuración, ya que los objetos están desacoplados entre sí y las interacciones están centralizadas en el mediador.
En C#, el patrón Mediator se puede implementar utilizando interfaces o clases abstractas para definir el mediador, y eventos o delegados para manejar la comunicación entre objetos. El mediador se puede inyectar en objetos mediante la inyección de dependencias y puede ser responsable de gestionar el estado general del sistema y coordinar las interacciones entre objetos.
Imagina que eres un gerente en un restaurante ocupado. Tienes camareros que toman los pedidos de los clientes, chefs que cocinan la comida y un cajero que maneja los pagos. A veces, puede haber una falta de comunicación entre los camareros y los chefs, lo que resulta en que se prepare la comida equivocada. O un cliente puede querer hacer una solicitud especial que no está en el menú.
Para simplificar este proceso y asegurarse de que todo funcione sin problemas, podrías implementar un mediador que actúe como intermediario entre los camareros, chefs y cajero. El mediador recibiría los pedidos de los camareros y los comunicaría a los chefs, asegurándose de que se prepare la comida correcta. Si hay una solicitud especial, el mediador podría manejarla comunicándola a la parte correspondiente.
En este escenario, el mediador actúa como la biblioteca MediatR en una aplicación de C#. Los camareros representan los pedidos que se realizan en la aplicación, los chefs representan los controladores que procesan esos pedidos y el mediador asegura que todo funcione sin problemas y que cada pedido sea manejado por el controlador correspondiente.
MediatR es una biblioteca que permite la implementación del patrón Mediator en aplicaciones ASP.NET Core. Proporciona una implementación del patrón Mediator y te permite desacoplar fácilmente los componentes de tu aplicación permitiéndoles comunicarse entre sí a través de un mediador.
El mediador en MediatR utiliza la reflexión para encontrar el controlador apropiado para esa solicitud. Cuando se envía una solicitud al mediador, este utiliza la reflexión para encontrar el controlador apropiado para esa solicitud.
Cada solicitud en MediatR debe implementar la interfaz IRequest, y cada controlador debe implementar la interfaz IRequestHandler con el tipo de solicitud adecuado especificado como parámetro genérico. Por ejemplo, si tienes una solicitud llamada CreateUserRequest, deberías implementar la interfaz IRequest con CreateUserRequest como parámetro genérico.
como parámetro genérico. Cuando el mediador recibe una CreateUserRequest, utilizará la reflexión para encontrar el controlador apropiado para esa solicitud, que en este caso sería el controlador que implementa IRequestHandler<CreateUserRequest>.
Una vez que se encuentra el controlador apropiado, MediatR llamará al método Handle en el controlador y pasará la solicitud como parámetro. El controlador es responsable de ejecutar la lógica asociada con la solicitud y devolver una respuesta.
En resumen, MediatR mapea las solicitudes a controladores utilizando la reflexión y los parámetros de tipo genérico de las interfaces IRequest e IRequestHandler. Cuando se recibe una solicitud, MediatR encuentra el controlador apropiado en función del tipo de solicitud y llama al método Handle en ese controlador.
En su núcleo, MediatR es simplemente un mediador que permite el acoplamiento débil entre los componentes de una aplicación. Define una tubería para manejar solicitudes y permite que los controladores se registren e invoquen por el mediador. La tubería se puede extender con comportamientos personalizados que pueden realizar acciones adicionales antes o después de que se maneje la solicitud.
Los componentes básicos de la biblioteca MediatR son:
Solicitud: este es un mensaje que se envía al mediador para desencadenar una solicitud. Puede ser cualquier objeto que represente un mensaje o un comando.
Controlador: este es el componente responsable de procesar la solicitud. Un controlador se registra en el mediador y recibe el objeto de solicitud cuando se invoca.
Mediador: este es el componente central que recibe solicitudes y las delega al controlador apropiado. También proporciona un mecanismo para registrar controladores.
Tubería: la tubería es una serie de comportamientos que se ejecutan antes o después de que se maneje la solicitud. La tubería se puede extender con comportamientos personalizados para realizar acciones adicionales.
La biblioteca MediatR proporciona una serie de abstracciones que hacen que sea fácil implementar el patrón Mediator en aplicaciones .NET, incluyendo:
IRequest e IRequestHandler: Estas son las interfaces que representan los objetos Request y Handler.
IRequestHandler<TRequest, TResponse>: Esta es una interfaz que implementa la interfaz IRequestHandler para un tipo de Request específico, con un tipo de retorno de TResponse.
IMediator: Esta es la interfaz que proporciona al objeto Mediator un método Send que toma un objeto IRequest y devuelve un objeto del tipo de respuesta apropiado.
Mediator: Esta es la implementación concreta de IMediator y es responsable de coordinar la comunicación entre Requests y Handlers.
Algunos de los beneficios de usar MediatR en tus aplicaciones .NET incluyen:
Mejora de la modularidad: MediatR te permite escribir código que es más modular, organizado y fácil de mantener.
Simplificación de las pruebas: El patrón Mediator hace que sea más fácil probar unidades de trabajo individuales, lo que simplifica la escritura de pruebas unitarias.
Mejora del rendimiento: El patrón Mediator reduce la necesidad de un acoplamiento estrecho entre objetos, lo que puede ayudar a mejorar el rendimiento de la aplicación.
Separación de preocupaciones: MediatR hace que sea fácil separar la lógica de negocio de tu infraestructura y código de plomería, lo que hace que tu código sea más mantenible con el tiempo.
En MediatR, los mensajes son objetos que encapsulan datos y representan una solicitud o notificación que necesita ser manejada por un handler. Hay dos tipos de mensajes en MediatR: mensajes de solicitud/respuesta y mensajes de notificación.
Los mensajes de solicitud/respuesta son mensajes que se envían a un solo handler y esperan una respuesta. Representan una solicitud de alguna acción o datos de la aplicación. Cuando se envía un mensaje de solicitud, se maneja por un solo handler que produce una respuesta.
Los mensajes de notificación, por otro lado, son mensajes que se envían a múltiples handlers y no esperan una respuesta. Representan un evento o cambio de estado en la aplicación que varios handlers pueden estar interesados en. Cuando se envía un mensaje de notificación, es manejado por múltiples handlers, cada uno de los cuales puede tomar diferentes acciones en respuesta al evento.
La distinción entre mensajes de solicitud/respuesta y mensajes de notificación es importante porque determina cómo se manejan los mensajes por el Mediator.
Los mensajes de solicitud/respuesta son manejados por un solo handler, mientras que los mensajes de notificación son manejados por múltiples handlers.
Cuando usas MediatR, creas un objeto de solicitud y un objeto de handler correspondiente. El objeto de solicitud representa los datos de entrada para una operación específica, y el objeto de handler contiene el código para realizar esa operación.
Cuando envías una solicitud a MediatR, este mira el objeto de solicitud para determinar qué objeto de handler debe manejar esa solicitud. Lo hace mediante el uso de una convención de nomenclatura que asigna el objeto de solicitud al objeto de handler correspondiente.
Por ejemplo, si tienes un objeto de solicitud llamado GetCustomerRequest, MediatR buscará un objeto de handler llamado GetCustomerRequestHandler. Si lo encuentra, llamará al método Handle en ese objeto y pasará el objeto de solicitud. El método Handle realizará la operación y devolverá el objeto de respuesta.
Entonces, en esencia, MediatR sabe dónde encontrar el código para procesar una solicitud mediante una convención de nomenclatura que asigna la solicitud al handler correspondiente. Esto hace que sea fácil agregar nuevas operaciones a tu aplicación, ya que solo necesitas crear un nuevo objeto de solicitud y un objeto de handler correspondiente, y MediatR se encargará del resto.
En caso de que alguien se pregunte, es posible tener dos solicitudes con el mismo tipo de solicitud pero diferentes handlers en MediatR. MediatR utiliza el tipo de solicitud para determinar qué handler invocar. Por lo tanto, siempre y cuando los tipos de solicitud sean distintos, puedes tener múltiples handlers para el mismo tipo de solicitud.
Sin embargo, si tienes dos o más handlers para el mismo tipo de solicitud, puede que necesites considerar cuál handler debe usarse para una solicitud en particular. MediatR proporciona varios mecanismos para controlar cómo se seleccionan los handlers para una solicitud, como el uso de un comportamiento de la tubería del mediador o la especificación explícita del handler a utilizar.
