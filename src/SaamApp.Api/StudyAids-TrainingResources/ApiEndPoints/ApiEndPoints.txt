Api EndPoints
In C# programming, MVC Controllers have been a staple in ASP.NET Core development for years. However, some of these controllers represent an outdated design pattern that no longer aligns with current object-oriented principles. Due to their limited manipulation of shared state, they lack cohesiveness and tend to become bloated and difficult to manage over time. Additionally, private methods within these controllers, if they exist, are typically only accessed by a single public method.
To combat these issues, many software developers advocate for leaner controllers. Controllers should be as concise as possible. However, due to the limited built-in alternatives, it is common practice for 99% of ASP.NET Core developers to rely on these traditional controllers.
There are workarounds for this issue, such as using tools like MediatoR to simplify the controllers. However, even these solutions still require extra implementation and can be a source of extra plumbing.
ASP.NET Core API Endpoints offer a better solution to this problem.
For the software application that accompanies this course, we have designed our API endpoints, to be a set of reusable classes and methods that handle the common tasks related to building APIs. This includes tasks such as input validation, error handling, and serialization. By doing so, we ensure that there is a clear separation of concerns between the application logic and the HTTP-specific details. This approach makes it easier to write clean and maintainable code.
We are leveraging a set of base classes that we inherit from to create our API endpoints, along with a set of attributes, that annotate our endpoint methods with metadata that defines their behavior. Additionally, we are utilizing the Swagger and OpenAPI tools to generate documentation for our API endpoints. By doing this, we make it easier for other developers to understand the structure and functionality of our APIs.
The ASP.NET Core API Endpoints are a modern and more organized approach to building APIs compared to the traditional MVC controllers. It adopts the concept of Razor Pages by breaking apart the overstuffed controllers and grouping the API models and endpoint logic into a simple and coherent structure. Instead of having separate controllers for different resources, the API Endpoints allows developers to simply create a folder per resource and group all related endpoints together. This results in a clear Request-Endpoint-Response (REPR) pattern that follows SOLID principles.
The Request-EndPoint-Response pattern is a simplified way of organizing the different components of a REST API. This pattern groups everything related to a particular API endpoint into a single, cohesive unit. It follows the SOLID principles of software development, particularly the Single Responsibility Principle (SRP) and the Open/Closed Principle (OCP).
In the Request-EndPoint-Response pattern, each API endpoint is responsible for handling a specific request, processing the necessary data and logic, and returning an appropriate response. This allows for a clear separation of concerns and makes it easier to maintain and update the code in the future. The grouping of related components also aligns with the Common Closure Principle, which states that components that change together should be grouped.
The use of the Request-EndPoint-Response pattern in API Endpoints helps to simplify the overall architecture and improve the maintainability of the code. Instead of having to navigate between multiple files in different folders to make changes to a single endpoint, the Request-EndPoint-Response pattern allows for all relevant components to be grouped in a single location, making it easier to understand and modify the code.
This pattern allows for better segregation of concerns, resulting in a decoupled architecture. This not only leads to a more organized codebase but also more reliable code as individual components can be tested and modified independently. Developers can be confident in the stability and reliability of their API as it grows and evolves.
Let's Study the Invoice Endpoint to retrieve a specific invoice from a database. The endpoint uses an HTTP GET request and takes an invoice ID as a parameter in the URL. The endpoint is called "GetByIdWithIncludes".
The endpoint retrieves the invoice using a custom specification which we saw in a previous chapter. The retrieved invoice and customer data are then mapped to corresponding DTO (Data Transfer Object) classes using AutoMapper. Finally, the endpoint returns an HTTP response with the retrieved data in the response body, in the form of a JSON object.
The class has three constructor parameters, all of which are dependencies that it needs to perform its work. These parameters are:
An IRepository Invoice instance.
An IRepository Customer instance.
An IMapper instance.
The class has an HTTP GET method defined with the [“Http Get”] attribute, to handle incoming HTTP GET requests to the specified route.
The “Http Get” attribute is used to specify that a particular action method should be called when an HTTP GET request is made to a specific URL.
When you define a route in your application, you can use attributes to specify the HTTP methods that should be used for each route. In this case, the “Http Get” attribute is applied to the HandleAsync method, which means that this method will be called when an HTTP GET request is made to the URL.
The “Http Get” attribute can provide additional information, such as:
Template: A string that specifies the URL template for the route. In this case, the template is api / invoices /i / InvoiceId.
Name: A string that provides a unique name for the route.
Order: An integer that specifies the order in which the route should be evaluated relative to other routes.
This is a common pattern in RESTful APIs, where each resource has its own URL and can be accessed using various HTTP methods, such as get, post, put, and delete.
Let's talk about the route
In this Invoice EndPoint , "api/invoices/i/InvoiceId" is the route template that is used to map incoming HTTP requests to this endpoint.
Let's break down the route template in more detail:
"api": This is a prefix that is often used to identify the API endpoints in a web application. It's not strictly necessary, but it can be a useful convention to follow.
"invoices": This is the name of the resource that is being accessed. In this case, it's an invoice.
"i": This is a sub-route , the reason why the "i" is added to the route template, in this case, is to create a distinguishable route from another similar endpoint with a similar route, we have another endpoint named GetById. By adding the "i" to the route, the GetByIdWithIncludes endpoint becomes uniquely identifiable, and the routing system can match incoming requests to the correct endpoint. This can be a useful convention to follow to make it easier to maintain and manage multiple endpoints in a web application.
"InvoiceId": This is a parameter that represents the ID of the invoice we want to retrieve. The curly braces indicate that this is a parameter that will be replaced with an actual value at runtime. In this case, the parameter is named InvoiceId.
So when a GET request is made to this URL with a specific invoice ID, the HandleAsync method in the class will be called with the corresponding object. The InvoiceId parameter from the URL will be automatically bound to the request.InvoiceId property, which is then used to retrieve the invoice from the repository and return it as a response.
The HandleAsync method is also decorated with the SwaggerOperation attribute. The SwaggerOperation attribute is used to provide additional metadata. The Swagger specification is a way to describe RESTful APIs in a standardized format, which can then be used to generate documentation, client libraries, and other tools.
The SwaggerOperation attribute can provide the following information:
Summary: A summary of what the method does.
Description: A longer description of the method, which may include additional details or examples.
OperationId: A unique identifier for the method, which can be used to refer to it in other parts of the Swagger specification.
Tags: An array of strings that can be used to group related methods in the documentation.
Now let's move to the HandleAsync method, we can see that It takes two parameters:
A GetByIdInvoiceRequest object, decorated with the “From Route” attribute. This is used to extract the InvoiceId value from the URL route. In ASP.NET Core, you can use attributes to specify how the runtime should bind values to parameters in your action methods. One of these attributes is “From Route”. This attribute tells the runtime to bind a parameter to a value from the route data, which is typically part of the URL.
When you define a route in your application, you can include placeholders for values that should be extracted from the URL. These placeholders are defined using curly braces. For example, in the Invoice EndPoint, the route template for the “Http Get” attribute is "api/invoices/i/InvoiceId". This means that the URL for this route should include a value for the InvoiceId parameter.
When you decorate a method parameter with the “From Route” attribute, ASP.NET Core will look for a value in the route data that matches the parameter name. If a value is found, it will be bound to the parameter. If no value is found, the parameter will be null.
In this Endpoint, the HandleAsync method has a parameter request that is decorated with the “From Route” attribute. This means that when the method is called, the runtime will look for a value in the route data that matches the name InvoiceId, which is the name of the property in the GetByIdInvoiceRequest class. If a value is found, it will be bound to the InvoiceId property.
This is a common pattern in RESTful APIs.
Therefore the HandleAsync method is responsible for handling the incoming HTTP request and generating an appropriate HTTP response.
The async keyword indicates that this is an asynchronous method. The override keyword means that this method is overriding a method defined in a base class, in this case, the HandleAsync method defined in the EndpointBaseAsync class.
In the EndpointBaseAsync class, the HandleAsync method is declared as virtual, which means that it can be overridden in derived classes.
In the derived class GetByIdWithIncludes, which is our endpoint, we need to provide an implementation for the HandleAsync method that is specific to this Invoice endpoint. By overriding the base method, we can customize the behavior of the endpoint to match our requirements.
By overriding this method, we can define the specific logic for this endpoint, which includes retrieving an invoice by ID from the repository, mapping the invoice to a DTO object, and returning the DTO object as a response.
The HandleAsync method returns a Task. This means that the method is asynchronous and will eventually return an ActionResult that wraps a GetByIdInvoiceResponse object.
when you call the HandleAsync method, it will immediately return a Task object that represents the ongoing operation, but the ActionResult will be generated later when the operation is complete. This is because the method uses the await keyword to asynchronously wait for the results of various operations, such as fetching data from the database or mapping objects before constructing the final result. When each await operation completes, the method returns control to the calling code and continues executing the remaining operations in the background. Once all the awaited operations are complete, the method constructs and return the final result as an ActionResult object, which can be used by the calling code to process the response.
The second parameter in the HandleAsync method is The CancellationToken, commonly used in ASP.NET Core to provide a mechanism for canceling long-running operations.
When an HTTP request is made to an API endpoint, the server may need to perform some long-running operations, such as reading from a database or calling an external service. In some cases, it may be necessary to cancel these operations before they are complete, for example, if the client cancels the request or if the server needs to shut down.
The CancellationToken parameter is used to provide a token that can be used to signal the cancellation of an operation. This token is passed down to lower-level APIs that support cancellation, such as database or network APIs. These APIs can periodically check the token, and if it has been canceled, stop processing and return control to the calling code.
For example, suppose the user clicks a button to fetch the full invoice record, which triggers a request to the server. If the user changes their mind and clicks another button to navigate away from the page, the application can use the cancellation token to cancel the ongoing request, freeing up resources on both the client and server.
Another example could be if the server needs to shut down due to maintenance or other reasons while a request is ongoing. The cancellation token can be used to cancel the ongoing request gracefully, avoiding any potential data corruption or errors.
The CancellationToken can be used to provide a mechanism for gracefully canceling ongoing requests in a variety of scenarios, improving the overall user experience and avoiding potential issues or data corruption.
now let's focus on the Response:
The GetByIdInvoiceResponse class is a response class used in the endpoint to return a response that includes an InvoiceDto object. The InvoiceDto object is used instead of the Invoice entity because it is a simplified version of the Invoice entity that only contains the data that is necessary for the client to consume.
The Invoice entity has a collection of child entities called InvoiceDetails, which are included in the InvoiceByIdWithIncludesSpec. By including the child entities, we can retrieve all the data related to the invoice in a single query, which can help reduce the number of round trips to the database.
Additionally, we're retrieving the Customer entity associated with the Invoice by its CustomerId. This is done so that we can retrieve the Customer information associated with the Invoice and include it in the response.
Once we have the Invoice with its invoice details and the Customer entity, we map them to their respective DTOs using AutoMapper and create the GetByIdInvoiceResponse object, which is returned as an Ok response. If the Invoice is not found, we return a NotFound response.
Let's talk about DTOs:
A DTO, or Data Transfer Object, is a class that represents a set of data that we want to transfer between different parts of our application. It's like a messenger between two different worlds, carrying only the information that is necessary for them to communicate.
Think of a DTO like a suitcase. When you go on a trip, you don't want to carry all of your clothes and belongings with you all the time. Instead, you pack only the essentials that you need for your trip and leave the rest behind. Similarly, a DTO only contains the necessary data for a specific operation and leaves behind the rest of the domain model's data.
In our endpoint, we use InvoiceDto and CustomerDto to represent the Invoice and Customer entities, respectively. These DTOs have the same properties as their corresponding entities, but they do not include any behavior or internal state.
The InvoiceDto is a DTO that represents the Invoice entity in a simplified and standardized way, suitable for transferring over the wire or using it as a view model. The CustomerDto is another DTO that similarly represents the Customer entity. By mapping the Invoice and Customer entities to their respective DTOs, we can create a standardized response object that is more suitable for communication with external systems or presenting to the user interface.
Some specific benefits of using DTOs include:
Efficient data transfer: When working with large datasets, DTOs can help reduce the amount of data sent over the network by including only the necessary data needed for a specific operation.
Enhanced security: DTOs can also be used to protect sensitive data by excluding it from the response. For example, entities that contain sensitive information such as passwords or credit card numbers can be selectively excluded from the data sent over the network.
Isolation of domain model: DTOs provide an abstraction layer between the domain model, e.g. Invoice entity, and external systems, e.g. API response, which helps to insulate the domain model from changes in external systems and vice versa.
Improved performance: DTOs can improve the performance of our application by sending only the necessary data to the client, thereby reducing the amount of data that needs to be transferred over the network.
Reduced coupling: Separating the domain model from the external interface using DTOs reduces coupling between different parts of the application. This makes it easier to modify or replace different parts of the application without affecting others.
Improved maintainability: Using DTOs to represent the input and output of our application provides a clear and stable interface that can be maintained and updated independently of the internal domain model, leading to better maintainability.
Improved scalability: By separating the input and output of our application from the internal domain model, DTOs can make it easier to horizontally scale the application by adding more instances of the API.
This can improve the reliability and availability of the application.
Let's focus on another endpoint, the Create Invoice details Endpoint, 
Firstly, let's talk about the Strategy pattern being used in this endpoint. The Strategy pattern is a behavioral design pattern that enables selecting an algorithm at runtime, based on the specific context in which it is being used. In this endpoint, the Strategy pattern is used to calculate the discount based on the selected discount strategy.
let me give you a real-life analogy for the Strategy pattern.
Imagine that you are a chef and you have to prepare a variety of dishes for your restaurant's menu. Each dish requires a different cooking technique or recipe, but the overall process of preparing the dish remains the same. You could choose to write a separate method for each dish, but that would quickly become unmanageable and difficult to maintain.
Instead, you could use the Strategy pattern. You would define an interface called "CookingStrategy" that defines a contract for preparing a dish. Then, you could create a set of concrete classes that implement this interface, each one representing a specific dish's cooking strategy, such as "GrillingStrategy," "BakingStrategy," "FryingStrategy," and so on.
When you receive an order for a particular dish, you could choose the appropriate strategy and pass it to your cooking context, which would use the strategy to prepare the dish. This way, you could easily switch between different cooking strategies, and add new ones as needed, without changing the overall cooking process.
In this analogy, the dishes represent different tasks, and the cooking strategies represent the algorithms or approaches to performing those tasks. The Strategy pattern allows you to encapsulate each strategy as an object, and switch between them at runtime, just like how you can switch between different cooking strategies to prepare different dishes in a restaurant.
Another real-life analogy for the Strategy pattern
Imagine you are going to a store to purchase a new phone, and the store offers different types of discounts based on your loyalty level. You could be a new customer, a regular customer, or a power buyer, and each level has a different discount percentage. The store could apply these discounts in various ways, such as reducing the final price or offering additional accessories.
In this scenario, the Strategy pattern can be used to apply the appropriate discount based on your loyalty level. The discount strategy is encapsulated in separate classes, which are interchangeable at runtime. The class implementing the discount strategy for a power buyer can be swapped with the class for a regular customer, depending on the loyalty level of the customer.
By using the Strategy pattern, the store can maintain a clear separation between the discount algorithm and the customer loyalty level, allowing for easier maintenance and modification in the future. Additionally, the store can add or remove discount strategies without modifying the existing code, making the application more scalable and adaptable to changing business requirements.
The request parameter DiscountStrategy is used to determine which discount strategy to use. Based on this value, an instance of the appropriate discount strategy is created and used to calculate the discount. This approach is extensible, as additional discount strategies can be easily added by implementing the IDiscountStrategy interface and updating the switch statement.
The goal here is to apply a discount to the line sale of a new invoice detail. To do that, we first create an instance of an interface called IDiscountStrategy and set it to null. This interface has a method called CalculateDiscount which takes an InvoiceDetail object and returns a discount value.
Next, the code uses a switch statement to determine which type of discount strategy to use. It looks at the value of DiscountStrategy which was sent in with the HTTP request. If it's "PowerBuyer", the code creates a new instance of the PowerBuyerDiscountStrategy class and assigns it to discountStrategyInstance. If it's "RegularCustomer", the code creates a new instance of the RegularCustomerDiscountStrategy class and assigns it to discountStrategyInstance. If the value of  DiscountStrategy is neither "PowerBuyer" nor "RegularCustomer", the code returns an HTTP BadRequest response with the message "Invalid discount strategy".
Now that the code has determined which discount strategy to use, it calls the CalculateDiscount method on discountStrategyInstance, passing in the new invoice detail object. The method returns a discount value, which the code stores in a variable called discount.
Finally, the code updates the LineSale property of the request object (which contains the new invoice detail information) by subtracting the product of the original LineSale and the discount value from the original LineSale.
So, we are using the Strategy pattern to determine which discount strategy to apply to a new invoice detail based on the type of customer (PowerBuyer or regular customer), and then applying that discount to the line sale of the new invoice detail.
It's important to understand the value of the Strategy pattern and how it can help manage complex business logic in an application.
As applications grow in complexity, managing all the different types of business logic that need to be implemented can become overwhelming. When developers are unsure of where to add business logic, they might scatter it throughout the application, leading to what's commonly known as "spaghetti code". This type of codebase can quickly become a nightmare to maintain, debug, and update. Imagine trying to work with a year's worth of spaghetti code! It's no wonder that developers strive to keep their code organized and maintainable.
Design patterns like the Strategy pattern help keep related code organized and encapsulated in a single location. Using this pattern in the example we saw earlier, we were able to isolate the discount calculation logic and encapsulate it in separate classes. This means that we can change or update our discount calculation logic at any time without affecting the rest of our application. We can also easily add new discount strategies as needed without changing the existing code.
In contrast, if we were to handle discount calculations directly in our code, we would scatter the discount logic throughout our application, creating a messy and confusing codebase that would be difficult to work with over time. The benefits of keeping code organized and maintainable are clear. By using design patterns like the Strategy pattern, we can create code that is easier to modify, manage, and update as the application evolves.
Secondly, let's talk about the fact that this is an Invoice detail Create endpoint, but we use the following line invoice.AddNewInvoiceDetail(newInvoiceDetail).
the Invoice Detail Create endpoint is responsible for handling incoming requests and returning responses. However, the actual creation of a new invoice detail entity is the responsibility of the core project of our Invoice Entity.
By separating these responsibilities, we can ensure that the API layer is not cluttered with business logic that doesn't belong there.
The API endpoint first retrieves the relevant invoice using a specification, then a new invoice detail object is created using the provided request parameters.
The 'AddNewInvoiceDetail' method is then called to add the newly created invoice detail to the relevant invoice. This method is part of the Invoice Entity, which we learned about in the Entities chapter of this course. The Invoice Entity is responsible for managing the state and behavior of invoice-related entities.
Now let's talk about Swagger:
SwaggerUI is a NuGet package that provides a user interface for Swagger in ASP.NET Core 7. Swagger is a popular open-source framework for describing, producing, consuming, and visualizing RESTful web services. It provides a user-friendly web page that enables developers to interact with and test their APIs. The UI is automatically generated based on the OpenAPI, formerly known as Swagger.
we need to enable the Swagger UI middleware and configure it in our application's Startup class.
we need to enable the middleware to serve the generated Swagger as a JSON endpoint. It makes the Swagger JSON document.
we also need to enable the middleware to serve the Swagger UI itself, specifying the Swagger JSON endpoint that the UI will consume.
Once you've completed these steps, you can run your application and navigate to the Swagger UI page to view the documentation for your API. The Swagger UI page provides a user-friendly interface for testing your API endpoints, including the ability to specify request parameters, view sample requests, and responses, and test the endpoint directly from the UI. SwaggerUI is a powerful tool for making it easy to test your API endpoints, way before any front end has been designed and it's a great addition to any ASP.NET Core project.
Let's take a look at our UI generated by swagger.
A header with the title "Get a Invoice by Id With Includes".
A short description of the endpoint just below the header, reading "Gets a Invoice by Id With Includes".
The HTTP verb for this endpoint (in this case, GET) and the route path, which will be /api/invoices/i/{InvoiceId}.
A section displaying the parameters for this endpoint, which will contain a single path parameter named InvoiceId.
A "Try it out" button that can be used to test the endpoint by providing a value for the InvoiceId parameter.
A "Responses" section displaying the possible HTTP responses, with examples of the response body in JSON format.
An "Example Value" section showing an example of the JSON response body that the endpoint will return.
A "Model" section displaying the structure of the response body object and its properties, including correlationId, invoice, and customer.
A "Schema" section displaying the schema for each of the properties in the response body.
A "Model Example" section showing an example of the JSON response body for each of the properties in the response body.
An "Implementation Notes" section providing any additional notes or information about the endpoint.
