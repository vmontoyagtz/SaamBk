    Eric Evans introduced the Specification pattern in his book on Domain Driven Design.
    Although the pattern is covered in the book, it is not listed in the mind map. However,
    the Specification pattern plays a much larger role in producing a clean domain model design,
    even though it doesn't receive the attention it deserves. According to Evans, specifications
    mesh smoothly with repositories, which are the building block mechanisms for providing query
    access to domain objects and encapsulating the interface to the database. The powerful combination
    of specification and repository patterns results in a clean, extensible,  design.
The Specification pattern is a software design approach that separates query-related logic from other parts of an application. This helps to make the code cleaner, easier to maintain and less prone to errors. By using this pattern, the need for complex expressions such as Where, Include, Select and the like, can be greatly reduced. In applications where a Repository abstraction layer is used, this pattern eliminates the need for many custom implementation classes and custom query methods. Instead of using a variety of methods to manipulate data, this pattern allows for the same functionality to be achieved with a smaller set of core methods. This results in a more streamlined, consistent, and maintainable codebase.
Think of a restaurant menu that has several items, each with a different combination of ingredients. If you wanted to order a specific dish with certain ingredients, you could use a special ordering specification to communicate that to the chef. For example, you might say, "I want the veggie burger, but with no pickles, extra avocado, and cooked medium-well." In software development, a specification is a similar concept, where you define a set of criteria that objects must meet in order to be selected or included in a specific result set. In the provided code, InvoiceByIdWithIncludesSpec is a specification that retrieves a specific invoice with related data, based on the provided invoice ID.
let us another real-life analogy for the Specification pattern.
Imagine that you are a car rental company that wants to ensure the quality of the cars you rent out to your customers. You have a set of criteria that every car must meet to be considered roadworthy and safe for driving.
To implement these criteria, you could use the Specification pattern. You would define a set of specifications that describe the car's characteristics, such as the model year, the engine size, the number of doors, and so on. Each specification would implement an interface that defines a single method called "IsSatisfiedBy," which takes a car object as a parameter and returns a Boolean value indicating whether the car meets the specification's criteria or not.
Then, you could combine these specifications using boolean operators such as AND, OR, and NOT, to create more complex specifications that define more specific requirements. For example, you could combine a "HasAirConditioningSpecification" with a "HasAutomaticTransmissionSpecification" to create a "LuxuryCarSpecification."
When a customer comes to rent a car, you could use these specifications to filter out the cars that do not meet their needs. You could search through your fleet of cars and check each one against the specifications until you find the ones that match. This way, you could ensure that every car you rent out meets your quality criteria, and provide a better experience for your customers.
In this analogy, the car rental company's criteria represent the specifications, and the cars represent the objects that are being evaluated. The Specification pattern allows you to encapsulate each specification as an object and combine them to create more complex ones, just like how you can combine multiple criteria to define a specific set of requirements for a rental car.
Another example
Imagine you're a librarian at a large public library. One of your jobs is to help customers find books that they're interested in. Customers often come to you with very specific requests, like "I'm looking for a book about World War II written by a British author that was published in the last 5 years and has a blue cover."
To find books that match these specific criteria, you might use a "BookSpecification" pattern. Just like in the restaurant example, you can create a class that takes in the customer's request and filters down a list of all the books in the library to only those that match the request.
For example, you might create a "BookByAuthorAndPubDateAndCoverColorSpec" that takes in the customer's requested author, publication date range, and cover color, and returns a list of all the books in the library that match those criteria.
Similarly, you might have a "CustomerByZipCodeAndAccountStatusSpec" that takes in a customer's zip code and account status and returns a list of all the library customers that match those criteria.
Imagine that you also need to retrieve detailed information about each book, including book child details, like the number of pages, genre, etc., as well as its "parent" customer, who borrowed the book, and when it's due back,. To accomplish this, you might create a "BookWithDetailsSpec" that takes in a book ID and returns all the detailed information about the book, including its child book details and parent customer information.
Using these Specification patterns, you can easily find the specific books and customers that customers are looking for, and provide them with all the detailed information they need.
The Specification pattern can be used in a wide range of scenarios. One of the most common use cases is in the context of filtering data, but it can also be used for validation, authorization, and other forms of business logic. It is particularly useful when dealing with large and complex systems, where separating the logic into smaller, more manageable pieces can make the code more maintainable and easier to understand.
The Specification class should have only one responsibility and that responsibility should be completely encapsulated by the class.
There's a tool called the Ardalis specification that makes it even easier to use the Specification pattern. It gives you a way to do complex filtering and sorting, and it makes your code more efficient. Instead of writing lots of different code to filter and sort information, you can use a few simple methods that do the job for you. This makes your code easier to understand and less likely to have mistakes.
The Specification pattern is especially helpful for big and complicated systems. When you have a lot of code, it can be hard to keep track of everything. But by using this pattern, you can break your code into smaller pieces, which makes it easier to understand and keep organized.
Think of it like putting all your laptops in different boxes. That way, you can find the laptop you want quickly and easily, without having to go through a big mess of laptops. The Specification pattern does the same thing for your code, making it easier to find and use the code you need.
Let's see some code:
This is an example of a specification class, named "InvoiceGetListSpec," 
The class starts by saying it's going to be working with a type of information called "Invoice". It then has a constructor, the method that gets called automatically when you create a new instance of the class, that sets up how to find the invoices we want.
The constructor says that we want to find invoices that are credit notes, which means invoices for when a customer returns something,  and then we want to order the invoices based on the delivery address id. Finally, the constructor says we don't want to keep track of changes to the invoices, this is called "AsNoTracking".
In other words, this class makes it easy for us to find all the credit note invoices and see them in order based on the delivery address, and it's done in a way that's efficient and easy to understand.
The code is a part of an API endpoint that lists invoices. The API endpoint is implemented as a class named List, which is derived from the EndpointBaseAsync class and implements the WithRequest<ListInvoiceRequest>.WithActionResult<ListInvoiceResponse> interface.
The List class has a constructor that takes two parameters: IRepository<Invoice> repository and IMapper mapper. These two objects are used later in the code to access the repository and map the invoices to their corresponding DTO (Data Transfer Object) representation.
The code in the HandleAsync method of the List class is executed when the API endpoint is called. This method has two parameters: ListInvoiceRequest request and CancellationToken cancellationToken. The request parameter contains information about the request made to the API endpoint, such as query parameters. The cancellationToken parameter is used to support the cancellation of the API call.
We create an instance of the InvoiceGetListSpec class, which is a specification for retrieving a list of invoices. The InvoiceGetListSpec specification specifies that only invoices with IsCreditNote equal to true should be retrieved and that they should be ordered by DeliveryAddressId.
Then we call the ListAsync method of the _repository object, which is an instance of the IRepository<Invoice> interface. The ListAsync method takes a specification as a parameter, in this case the spec variable created in the previous line. The ListAsync method returns a list of invoices that match the conditions specified in the specification.
Notice that repository.ListAsync  is an asynchronous method call that takes a Specification<Invoice> object as a parameter.
In this case, the spec parameter is an instance of InvoiceGetListSpec, which is a subclass of the Specification<Invoice> class. 
The ListAsync method is expected to use the specification to filter and sort the data in the repository before returning a list of entities.
Remember that  InvoiceGetListSpec is defined to retrieve only invoices where IsCreditNote is true, and order the results by DeliveryAddressId. When ListAsync is called with this specification, it will apply these criteria to the data in the repository and return the filtered and sorted list of invoices.
The result of the ListAsync method is stored in the invoices variable. If no invoices were found, the NotFound method is called, which returns an HTTP 404 (Not Found) response to the client. If invoices were found, they are mapped to their corresponding DTO representation using the _mapper object, and the resulting list of invoices is returned to the client as a ListInvoiceResponse object in an HTTP 200 (OK) response.
Lets examine the IRepository<Invoice> repository
When we pass the entity Invoice as a parameter to IRepository<Invoice> repository, we are creating an instance of a repository that is specialized in handling entities of type Invoice. This allows us to perform operations on a collection of Invoice entities, such as querying, adding, updating, and deleting.
The repository implementation can use this information to provide methods that are specific to the type of entity being manipulated. For example, the ListAsync method would expect to receive a Specification<Invoice> object that defines the criteria for querying Invoice entities.
By using a strongly-typed repository, the code becomes more readable, maintainable, and less error-prone, as the type of entities being manipulated is explicitly defined.
IRepository is a part of the Ardalis.Specification NuGet package.
Then we have the InvoiceByIdWithIncludesSpec, which inherits from the Specification<Invoice> class and implements the ISingleResultSpecification interface.
This class is used as a specification to retrieve a single invoice entity with its related invoice details, based on the invoice id passed as a parameter to its constructor.
The constructor first uses Guard Clauses to ensure that the invoiceId parameter is not null or empty.
Then, the Query property is used to build a LINQ query, where it specifies to return an Invoice entity where its InvoiceId property matches the invoiceId parameter and its IsCreditNote property is true. The query also orders the result by the DeliveryAddressId property and includes the related InvoiceDetails for the retrieved Invoice. The AsNoTracking method is called to indicate that the result of this query should not be tracked by the Entity Framework's change tracker.
In the CustomerAddressByRelIdsSpec specification class, we are querying the CustomerAddress table, but instead of using the primary key of the CustomerAddress table, we are using the foreign keys, customerId and addressId, which are the primary keys of the Customer and Address tables respectively. 
This is a common practice when working with join tables, as they typically do not have their own unique identifier, but rather rely on the primary keys of the tables they are joining. 
It checks that these keys have valid values before using them in the query. 
We then use these foreign keys to filter the CustomerAddress table and only return the rows that have matching customerId and addressId. 
