Domain Events and Integration Events are both events that are used in microservices and distributed systems to communicate and coordinate changes between different parts of a system. However, they differ in their scope and purpose.
Domain Events are used to communicate changes that happen within a single microservice or bounded context. They represent something that has occurred within a domain model and are intended to notify other parts of the same microservice or bounded context about the event. These events are published and subscribed to within a single process, and the domain event handler logic is executed in memory within the same process. Domain Events enable loose coupling between different parts of a microservice and help to keep the different parts of the system isolated from one another.
For example, suppose a user buys something. You may want to update his shopping cart, withdraw money from his wallet, create a new shipping order, and perform other domain operations that are not a concern of an aggregate that executes a "buy" command. The typical approach involves executing all this logic in a service that performs a "buy" operation, creating coupling between different subdomains.
An alternative approach would be publishing a Domain Event. If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you can design and implement those side effects to be triggered by Domain Events. Propagation of state changes across multiple aggregates within the same domain model can be performed by subscribing to a concrete Domain Event and creating as many event handlers as needed.
A significant advantage of Domain Events is that they help in maintaining consistency and integrity of your data. All changes caused by Domain Events across multiple aggregates in a single process can be saved in a single database transaction. This approach ensures consistency and integrity of your data. Wrapping an entire flow in a transaction or using patterns like Unit of Work or similar can help with that. However, it's crucial to keep in mind that overusing transactions can create bottlenecks when multiple users try to modify a single record concurrently. Therefore, use them only when you can afford it, otherwise go for other approaches like eventual consistency.
There are several ways to implement an event bus for Domain Events. You can use ideas from patterns like Mediator or Observer. Additionally, Domain Events may be useful for creating an audit log to track all changes to important entities by saving each event to the database. This is useful when you want to keep a record of what changes were made to a specific entity and when they occurred.
To have a better understanding of Domain Events and their implementation, you can read the Domain Event pattern and Domain Events: design and implementation.
Domain Events are an essential part of Domain-Driven Design and microservices architectures. A Domain Event is a message that indicates something happened in a domain and you want other parts of the same domain (in-process) to be aware of it. The main purpose of Domain Events is to enable loose coupling between different subdomains and aggregates.
However, it's important to note that when using only events for complex workflows with a lot of steps, it can be difficult to track everything that is happening across the application. One event may trigger another one, and then another one, and so on. To track the entire workflow, you'll have to go to multiple places and search for an event handler for each step, which can be hard to maintain. In this case, using a service/orchestrator/mediator might be a preferred approach compared to only using events since you will have an entire workflow in one place. This might create some coupling, but it is easier to maintain. Remember to choose the right tool for the job.
In some cases, you may not be able to save all changes made by your events to multiple aggregates in a single transaction. For example, if you are using microservices that span transactions between multiple services or the Event Sourcing pattern that has a single stream per aggregate, saving events across multiple aggregates can be eventually consistent. In such cases, you can use Sagas with compensating events, a Process Manager, or something similar to maintain eventual consistency.
