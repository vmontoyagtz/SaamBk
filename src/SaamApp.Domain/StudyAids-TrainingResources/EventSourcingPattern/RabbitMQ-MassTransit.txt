In our application we will use RabbitMQ with MassTransit.
By using RabbitMQ with MassTransit, we will make our application more scalable , resilient, and decoupled application that can handle a high volume of messages with ease.
Retry policies: MassTransit provides a set of built-in retry policies that can be used to automatically retry failed message deliveries. You can also create custom retry policies that are tailored to your specific needs. The built-in retry policies include exponential backoff, immediate retries, and retry intervals.
malfunction. A retry policy would be like pressing the same button again to give the machine another chance to dispense the item. If the first retry attempt fails, you can try again a few more times, each time waiting for a short period before retrying.
Circuit breakers: A circuit breaker is a design pattern that can prevent repeated requests to a failing service or component. MassTransit provides a circuit breaker component that can be used to prevent overloading a failing RabbitMQ instance with messages. The circuit breaker monitors the number of failed requests and can be configured to trip and fail fast, preventing further requests until the underlying issue is resolved.
A circuit breaker can be compared to a safety switch that is installed in an electrical system to prevent damage to the system during a power surge or other electrical fault. In a software system, a circuit breaker monitors requests to external services and, if too many requests fail, it "trips" and stops sending requests to the service. This helps to prevent further damage or delays while the service is being restored.
Message re-queuing: MassTransit provides the ability to re-queue messages that have failed delivery to a RabbitMQ instance. This allows failed messages to be automatically retried using the retry policies or circuit breaker components, without manual intervention.
Think of a postal worker who is trying to deliver a package to your house, but they find the address is incomplete or incorrect. The postal worker returns the package to the post office, where it is re-routed to the correct address. In a software system, re-queuing messages is similar to returning the message to the queue when it can't be processed, so it can be picked up again and re-routed to the correct processing component.
Dead-letter queues: A dead-letter queue is a queue that holds messages that have failed delivery for a configurable amount of time. MassTransit allows you to configure a dead-letter queue for your RabbitMQ instance, which can be used to hold failed messages for later inspection and analysis.
A dead-letter queue is like a "lost and found" department in a large store. When an item is misplaced, it is sent to the lost and found, where it can be retrieved by the owner. Similarly, in a messaging system, a dead-letter queue is a storage area where messages are sent if they can't be delivered to their intended destination. This allows administrators to investigate and resolve any issues that may have prevented the message from being processed.
Message serialization is also an important feature of MassTransit when using RabbitMQ.
When messages are exchanged between applications, they need to be serialized and deserialized to ensure that they can be correctly interpreted by the receiving application. MassTransit provides built-in support for several serialization formats.
By default, MassTransit uses JSON serialization to convert messages to and from a message broker. However, it also supports other formats such as XML, Protocol Buffers, and MessagePack.
One important aspect of message serialization is the ability to evolve message formats over time. As requirements change and new features are added, it may be necessary to modify the structure of messages being sent over the bus. MassTransit's support for multiple serialization formats makes it easier to handle these changes without breaking backward compatibility.
Now imagine that you're traveling to a foreign country where they have different electrical outlets. You need to bring a converter so that your devices can be charged properly. This is similar to how different systems may require different message formats, and the serializer is responsible for converting the message from one format to another. Just like how you need a converter to make sure your devices work in a different country, the serializer makes sure that the message can be properly understood by the system that receives it.
We will build a history mechanism, to capture all the information when an invoices gets updated, created or deleted.
Using this approach, we can maintain a complete history of all transactions related to an invoice, making it easier to analyze the data and generate audit trails.
Before exploring event sourcing, it is essential to have a grasp of the distinctions between two commonly used libraries - MediatR and MassTransit.
MediatR is a library that works by handling requests and notifications through handlers that are responsible for performing the necessary actions. MediatR is great for implementing simple and straightforward request/response patterns, as well as for event-driven architecture.
Some use cases for MediatR include:
Handling requests from the user interface, such as creating, updating, or deleting records in a database.
Responding to events in your application, such as a user logging in or out.
Implementing CQRS (Command Query Responsibility Segregation) patterns in your application.
MediatR is like calling a specific person on the phone and asking them to do something for you. You have a direct line of communication with that person and they will respond to you directly. In software terms, MediatR provides direct communication between components in a system.
When using MediatR, you can only send one request and get back one response. This means that the request is linked to a specific response type, and you can be sure that you will receive a response in the same type as the request.
MassTransit, on the other hand, is a more powerful library that provides a robust message-based architecture for distributed systems. It allows you to send and receive messages across multiple services and systems, making it great for large-scale distributed applications.
Some use cases for MassTransit include:
Building an event-driven architecture that involves multiple services and systems.
Implementing a distributed message bus that can handle high throughput and low latency scenarios.
Decoupling your application's services and systems, allows them to operate independently.
MassTransit is like sending a message to a company's customer service department. You don't know exactly who will respond to your message, but you know that someone will eventually see it and respond to you. In software terms, MassTransit provides a messaging system that allows components to communicate with each other without necessarily knowing the exact recipient of the message.
One difference between MediatR and MassTransit is that MediatR is focused on request/response patterns, whereas MassTransit is focused on message-based architecture. In addition, MediatR requires that the input payload implements the IRequest or INotification interface, whereas MassTransit only requires a simple POCO (Plain Old CLR Object) class.
Another important difference is in how they handle crashes and failures. In MediatR, the sender side will crash if the consumer crashes, and the request type is attached to the response type. On the other hand, in MassTransit, the sender side will only receive a response if the consumer publishes it, and the sender side will not crash if the consumer crashes.
When using MassTransit, you can send one request and get back multiple response types. This means that there is no guarantee that you will receive a response in the same type as the request, and the consumer may even forget to send a response. Additionally, if the consumer sends a response that doesn't match what the sender is expecting, a timeout will also occur
Overall, MediatR is a great library for implementing simple request/response patterns and event-driven architecture, while MassTransit is better suited for building large-scale distributed systems that require robust message-based architecture.
